//------------------------------------------------------------------------------------------------
//------10.01-----面试例题1
/*
面向对象的设计三原则：封装 继承 多态
1.里氏代换原则：任何基类可以出现的地方，子类一定可以出现。是继承复用的基石
2.开-闭原则：对扩展开放 对修改关闭
3.防御式编程：只是一种编程技巧
*/
//------------------------------------------------------------------------------------------------
//------10.01-----面试例题2
/*
virtual 多态
interface 继承
private 封装
*/
//------------------------------------------------------------------------------------------------
//------10.01-----面试例题1
/*
c++中的空类默认产生什么类成员函数
构造函数-析构函数
拷贝构造函数
赋值函数
4个
*/
//------------------------------------------------------------------------------------------------
//------10.02-----面试例题1
/*
struct可以有成员函数，默认public
*/
//------------------------------------------------------------------------------------------------
//------10.02-----面试例题2
/*
#include <stdio.h>
#include <iostream>
using namespace std;
struct Test{
	Test(int) {}
	Test() {}
	void fun(){}
};
int main(){
	Test a(1);
	a.fun();
	Test b();
	b.fun();
	return 0;
}
*/

//------------------------------------------------------------------------------------------------
//------10.03-----面试例题1
/*
静态成员数据是在这个类中的所有对象间共享的
*/
//------------------------------------------------------------------------------------------------
//------10.03-----面试例题2
/*
#include <iostream>
using namespace std;
class Cat{
public:
	Cat(int age):itsAge(age){HowManyCats++;}
	virtual ~Cat() {HowManyCats--;}
	virtual int GetAge(){return itsAge;}
	virtual void SetAge(int age){
		itsAge = age;
	}
	static int HowManyCats;
private:
	int itsAge;
};
int Cat::HowManyCats = 0;
int main(){
	const int MaxCats = 5;
	int i;
	Cat *CatHouse[MaxCats];
	for(i=0;i<MaxCats;i++){
		CatHouse[i] = new Cat(i);
	}
	for (i=0;i<MaxCats;i++)
	{
		cout<<"there are";
		cout<<Cat::HowManyCats;
		cout<<"cats left!";
		cout<<CatHouse[i]->GetAge();
		cout<<"years old\n";
		delete CatHouse[i];
		CatHouse[i] = 0;
	}
	return 0;
}
*/
//没有给静态成员变量赋初值
//private之后可以用公有静态成员访问

//------------------------------------------------------------------------------------------------
//------10.03-----面试例题3
/*
class base{
private:
	int m_i;
	int m_j;
public:
	base(int i):m_j(i),m_i(m_j) {}
};
*/
//初始化列表的初始顺序是按照成员变量的声明顺序来执行的
//------------------------------------------------------------------------------------------------
//------10.03-----面试例题4
/*
#include <iostream>
using namespace std;
class A{
	const int size = 0;
};
//常量必须在构造函数的初始化列表里初始化
*/
//------------------------------------------------------------------------------------------------
//------10.04-----面试例题1
//为什么虚拟的析构函数是必要的？
/*
CBase *pbase;
CChild c;
pbase = &c;
*/
//------------------------------------------------------------------------------------------------
//------10.04-----面试例题2
//为什么构造函数不能为虚？
/*

  1. 从存储空间角度，虚函数对应一个指向vtable虚函数表的指针，这大家都知道，可是这个指向vtable的指针其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。
  2. 从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
  3. 构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。
  4. 从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有必要成为虚函数。
  5. 当一个构造函数被调用时，它做的首要的事情之一是初始化它的VPTR。因此，它只能知道它是“当前”类的，而完全忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码――既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。所以它使用的VPTR必须是对于这个类的VTABLE。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE, 但如果接着还有一个更晚派生的构造函数被调用，这个构造函数又将设置VPTR指向它的 VTABLE，等.直到最后的构造函数结束。VPTR的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的另一个理由。但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置VPTR指向它自己的VTABLE。如果函数调用使用虚机制，它将只产生通过它自己的VTABLE的调用，而不是最后的VTABLE（所有构造函数被调用后才会有最后的VTABLE）。

*/
//------------------------------------------------------------------------------------------------
//------10.04-----面试例题3
//虚函数的对象必须维护一个V表，会产生系统开销

//------------------------------------------------------------------------------------------------
//------10.04-----面试例题4
//内联函数
/*
#include <iostream>
using namespace std;
class A{
public:
	void foo(){
		cout<<"a"<<endl;
	}
	~A();
};
inline A::~A(){
	cout<<"inline";
}
int main(){
	A *niu = new A();
	niu->foo();
	delete niu;
	return 0;
}
*/
//析构函数可以内联函数

//------------------------------------------------------------------------------------------------
//------10.04-----面试例题5
/*
#include <iostream>
#include <string>
#include <vector>
using namespace std;
class B{
private:
	int data;
public:
	B(){
		cout<<"default constructor"<<endl;
	}
	~B(){
		cout<<"destructor"<<endl;
	}
	B(int i):data(i){
		cout<<"contricted by paramter"<<data<<endl;
	}
};
B Play(B b){
	return b;
}
int main(){
	B temp = Play(5);
	return 0;
}
*/

